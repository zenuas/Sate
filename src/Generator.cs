using Microsoft.CodeAnalysis;
using Sate.Block;
using Sate.Expression;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace Sate;

[Generator(LanguageNames.CSharp)]
public class Generator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var project_dir = context.AnalyzerConfigOptionsProvider
            .Select(static (x, token) => (
                ProjectDir: x.GlobalOptions.TryGetValue("build_property.ProjectDir", out var project_dir) ? project_dir : "",
                RootNamespace: x.GlobalOptions.TryGetValue("build_property.RootNamespace", out var root_namespace) ? root_namespace : ""
            ));

        context.RegisterSourceOutput(
            context
                .AdditionalTextsProvider
                .Combine(project_dir)
                .Where(x => x.Left.Path.EndsWith(".ts.sql"))
                .Select((x, token) => (AdditionalText: x.Left, SourceText: x.Left.GetText(token), Option: x.Right))
                .Where(x => x.SourceText != null)
                .Select((x, token) =>
                {
                    var file_name = Path.GetFileName(x.AdditionalText.Path);
                    var dir_path = Path.GetDirectoryName(x.AdditionalText.Path);
                    var relative_path = dir_path.StartsWith(x.Option.ProjectDir) ? dir_path.Substring(x.Option.ProjectDir.Length) : "";
                    var class_name = file_name.Substring(0, file_name.IndexOf('.'));
                    var ns_name = (relative_path == "" ? x.Option.RootNamespace : $"{x.Option.RootNamespace}.{PathToNamespace(relative_path)}");
                    return (
                        HintName: $"{ns_name}.{class_name}.cs",
                        Source: GenerateSource(ns_name, class_name, LineParser.ParseTopLevel([.. x.SourceText!.Lines.Select(x => x.ToString())]))
                    );
                }),
            (sp, x) => sp.AddSource(x.HintName, x.Source)
        );
    }

    public static string PathToNamespace(string path) => path.Replace(Path.DirectorySeparatorChar, '.');

    public static string GenerateSource(string ns_name, string class_name, IEnumerable<IBlock> blocks)
    {
        var src = new StringBuilder();
        src.AppendLine($$"""
// <auto-generated/>

namespace {{ns_name}}
{
    public static class {{class_name}}
    {
        public static string Build(IParameter @arg)
        {
            var @s = new System.Text.StringBuilder();
""");
        var parameters = new Dictionary<string, Type?>();
        OutputSources(src, 3, blocks, parameters);
        src.AppendLine("""
            return @s.ToString();
        }

        public static string Build(Parameter @arg) => Build((IParameter)@arg);

        public static string Build(dynamic @arg)
        {
            var @param = new Parameter()
            {
""");
        foreach (var kv in parameters)
        {
            src.AppendLine($"                {kv.Key} = @arg.{kv.Key},");
        }
        src.AppendLine("""
            };
            return Build((IParameter)@param);
        }

        public interface IParameter
        {
""");
        foreach (var kv in parameters)
        {
            src.AppendLine($"            public {kv.Value!.FullName} {kv.Key} {{ get; init; }}");
        }
        src.AppendLine("""
        }

        public class Parameter : IParameter
        {
""");
        foreach (var kv in parameters)
        {
            src.AppendLine($"            public {(kv.Value!.IsClass ? "required " : "")}{kv.Value!.FullName} {kv.Key} {{ get; init; }}");
        }
        src.AppendLine("""
        }
    }
}
""");
        return src.ToString();
    }

    public static void OutputSources(StringBuilder src, int indent, IEnumerable<IBlock> blocks, Dictionary<string, Type?> parameters)
    {
        var sp = new string(' ', indent * 4);

        foreach (var block in blocks)
        {
            if (block is StaticBlock s)
            {
                src.AppendLine($"{sp}@s.AppendLine(@\"{s.Value}\");");
            }
            else if (block is IfBlock ifs)
            {
                src.AppendLine($"{sp}if ({OutputExpression(ifs.Condition, parameters)})");
                src.AppendLine($"{sp}{{");
                OutputSources(src, indent + 1, ifs.Then, parameters);
                src.AppendLine($"{sp}}}");

                if (ifs.Else.Length > 0)
                {
                    src.AppendLine($"{sp}else");
                    src.AppendLine($"{sp}{{");
                    OutputSources(src, indent + 1, ifs.Else, parameters);
                    src.AppendLine($"{sp}}}");
                }
            }
        }
    }

    public static string OutputExpression(string expr, Dictionary<string, Type?> parameters) => OutputExpression(LineParser.ParseExpression(expr).Node, parameters);

    public static string OutputExpression(Node node, Dictionary<string, Type?> parameters, Type? type = null)
    {
        switch (node.Operand)
        {
            case Operands.LeftParenthesis:
                {
                    var s = $"({OutputExpression(node.Left!, parameters, type)})";
                    return s;
                }

            case Operands.Operand:
                {
                    var s = LineParser.IsUnaryOperator(node)
                        ? $"{node.Value}{OutputExpression(node.Right!, parameters, typeof(int))}"
                        : $"{OutputExpression(node.Left!, parameters, type)} {node.Value} {OutputExpression(node.Right!, parameters, type)}";

                    if (node.Left?.Operand == Operands.Variable)
                    {
                        var name = node.Left.Value.ToString();
                        if (type is { })
                        {
                            EvaluateType(name, type, parameters);
                        }
                        else
                        {
                            EvaluateType(name, node.Right!, parameters);
                        }
                    }
                    if (node.Right?.Operand == Operands.Variable)
                    {
                        var name = node.Right.Value.ToString();
                        if (type is { })
                        {
                            EvaluateType(name, type, parameters);
                        }
                        else
                        {
                            EvaluateType(name, node.Left!, parameters);
                        }
                    }
                    return s;
                }

            case Operands.Number:
                return node.Value.ToString();

            case Operands.Variable:
                {
                    var v = node.Value.ToString();
                    var name = LineParser.IsVariablePrefix(v[0]) ? v.Substring(1) : v;
                    if (!parameters.ContainsKey(name)) parameters.Add(name, null);
                    return $"@arg.{name}";
                }

            case Operands.String:
                return $"\"{EscapeString(node.Value.ToString())}\"";
        }
        throw new Exception();
    }

    public static Type? EvaluateType(string name, Type type, Dictionary<string, Type?> parameters)
    {
        var p = LineParser.IsVariablePrefix(name[0]) ? name.Substring(1) : name;
        return parameters[p] = type;
    }

    public static Type? EvaluateType(string name, Node node, Dictionary<string, Type?> parameters)
    {
        switch (node.Operand)
        {
            case Operands.LeftParenthesis:
                return EvaluateType(name, node.Left!, parameters);

            case Operands.Operand:
                return node.Left is { } left
                    ? EvaluateType(name, left, parameters) ?? EvaluateType(name, node.Right!, parameters)
                    : EvaluateType(name, node.Right!, parameters);

            case Operands.Number:
                return EvaluateType(name, typeof(int), parameters);

            case Operands.Variable:
                return parameters.TryGetValue(name, out var t) && t is { }
                    ? EvaluateType(name, t, parameters)
                    : null;

            case Operands.String:
                return EvaluateType(name, typeof(string), parameters);
        }
        throw new Exception();
    }

    public static string EscapeString(string s) => s.Replace("\"", "\\\"");
}
