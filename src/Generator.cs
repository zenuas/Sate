using Microsoft.CodeAnalysis;
using Sate.Block;
using Sate.Expression;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace Sate;

[Generator(LanguageNames.CSharp)]
public class Generator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var project_dir = context.AnalyzerConfigOptionsProvider
            .Select(static (x, token) => (
                ProjectDir: x.GlobalOptions.TryGetValue("build_property.ProjectDir", out var project_dir) ? project_dir : "",
                RootNamespace: x.GlobalOptions.TryGetValue("build_property.RootNamespace", out var root_namespace) ? root_namespace : ""
            ));

        context.RegisterSourceOutput(
            context
                .AdditionalTextsProvider
                .Combine(project_dir)
                .Where(x => x.Left.Path.EndsWith(".ts.sql"))
                .Select((x, token) => (AdditionalText: x.Left, SourceText: x.Left.GetText(token), Option: x.Right))
                .Where(x => x.SourceText != null)
                .Select((x, token) =>
                {
                    var file_name = Path.GetFileName(x.AdditionalText.Path);
                    var dir_path = Path.GetDirectoryName(x.AdditionalText.Path);
                    var relative_path = dir_path.StartsWith(x.Option.ProjectDir) ? dir_path.Substring(x.Option.ProjectDir.Length) : "";
                    var class_name = file_name.Substring(0, file_name.IndexOf('.'));
                    var ns_name = (relative_path == "" ? x.Option.RootNamespace : $"{x.Option.RootNamespace}.{PathToNamespace(relative_path)}");
                    return (
                        HintName: $"{ns_name}.{class_name}.cs",
                        Source: GenerateSource(ns_name, class_name, LineParser.ParseTopLevel([.. x.SourceText!.Lines.Select(x => x.ToString())]))
                    );
                }),
            (sp, x) => sp.AddSource(x.HintName, x.Source)
        );
    }

    public static string PathToNamespace(string path) => path.Replace(Path.DirectorySeparatorChar, '.');

    public static string GenerateSource(string ns_name, string class_name, IEnumerable<IBlock> blocks)
    {
        var src = new StringBuilder();
        src.AppendLine($$"""
// <auto-generated/>

namespace {{ns_name}}
{
    public static class {{class_name}}
    {
        public static string Build(dynamic @arg)
        {
            var @s = new System.Text.StringBuilder();
""");
        OutputSources(src, 3, blocks);
        src.AppendLine("""
            return @s.ToString();
        }
    }
}
""");
        return src.ToString();
    }

    public static void OutputSources(StringBuilder src, int indent, IEnumerable<IBlock> blocks)
    {
        var sp = new string(' ', indent * 4);

        foreach (var block in blocks)
        {
            if (block is StaticBlock s)
            {
                src.AppendLine($"{sp}@s.AppendLine(@\"{s.Value}\");");
            }
            else if (block is IfBlock ifs)
            {
                src.AppendLine($"{sp}if ({OutputExpression(ifs.Condition)})");
                src.AppendLine($"{sp}{{");
                OutputSources(src, indent + 1, ifs.Then);
                src.AppendLine($"{sp}}}");

                if (ifs.Else.Length > 0)
                {
                    src.AppendLine($"{sp}else");
                    src.AppendLine($"{sp}{{");
                    OutputSources(src, indent + 1, ifs.Else);
                    src.AppendLine($"{sp}}}");
                }
            }
        }
    }

    public static string OutputExpression(string expr) => OutputExpression(LineParser.ParseExpression(expr).Node);

    public static string OutputExpression(Node node)
    {
        switch (node.Operand)
        {
            case Operands.LeftParenthesis:
                return $"({OutputExpression(node.Left!)})";

            case Operands.Operand:
                return LineParser.IsUnaryOperator(node)
                    ? $"{node.Value}{OutputExpression(node.Right!)}"
                    : $"{OutputExpression(node.Left!)} {node.Value} {OutputExpression(node.Right!)}";

            case Operands.Number:
                return node.Value.ToString();

            case Operands.Variable:
                var v = node.Value.ToString();
                return $"@arg.{(LineParser.IsVariablePrefix(v[0]) ? v.Substring(1) : v)}";

            case Operands.String:
                return $"\"{node.Value}\"";
        }
        throw new Exception();
    }
}
